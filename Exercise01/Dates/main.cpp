/* 
 * File:   main.cpp
 * Author: Dimitar
 *
 * Created on March 29, 2015, 5:34 PM
 */

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

/*
 * Първо рагледахме какво е това структура.
 * В С структурите са били предназначени просто да събират някакви данни на едно място.
 * Също така, в С, в структурите нямаме методи.
 * 
 * В С++ това вече е възможно, но все пак не се ползва, като за тази цел имаме класове,
 * каквито главно ще използваме.
 * 
 * 
 * Задача 1.
 * a) Да се напише структура Date, която да има променливи за ден, месец и година.
 */
struct Date {
    int day;
    int month;
    int year;
};

/*
 * b) да се предефинира оператора за сравнение < за структурата Date.
 * 
 * Този оператор връща true, ако първата дата е "по-малка" от вротата и false в останалите случай.
 * Подаваме двете дати като const и по референция.
 * 
 *      Ключовата дума const в случая ни помага да се застраховаме, че аргументите, който
 *      подаваме няма да бъдат променяни. Ако пробваме да променим нещо, компилатора ще се оплачи.
 * 
 *      Подаване по референция - &:
 *          При подаване на аргументи на дадена функция, ако аргументите се подават по
 *          стойност тяхното съръджание се копира в нова променлива, която в действителност се подава
 *          на функцияата.
 * 
 *          При подаване по референция подаваме адреса на променливата - спестяваме си едно копиране.
 *          Тука има опасност, че ако променим променливата във функцията - и реалната променлива ще се
 *          промени. Понякога това е идеята, но в случая искаме нещата да си останат както са.
 *          
 *          http://goo.gl/m5sDc6
 */
bool operator<(const Date& d1, const Date& d2) {

    if (d1.year == d2.year) {

        if (d1.month == d2.month) {

            return d1.day < d2.day;

        } else {
            return d1.month < d2.month;
        }

    } else {
        return d1.year < d2.year;
    }
}

/*
 * c) Да се предефинира оператора за печатане в конзолата << 
 * 
 * Тук нещата са малко по-сложни, защото предефинирането на този оператор приема
 * като аргумент и връща ostream& (output stream или изходен поток), който служи
 * за печатане по конзолата. Той е част от библиотеката iostream.
 * 
 * Приемайте го като все едно подавате cout.
 * 
 *  http://www.cplusplus.com/reference/ostream/ostream/ 
 */
ostream& operator<<(ostream& os, const Date& d) {

    os << d.day << "." << d.month << "." << d.year;

    return os;
}

/*
 * d) Направете си един масив от няколко дати, сортирайте ги и изпечатайте сортирания
 *    масив в конзолата.
 */
int main(int argc, char** argv) {

    Date datesArray[] = {
        {1, 1, 2013},
        {1, 1, 2014},
        {2, 1, 2013},
        {12, 1, 2008},
        {1, 1, 2009},
        {1, 3, 2011},
        {1, 1, 2009}
    };

    int numberOfDates = 7;


    /*
     * sort функцията служи за сортиране.
     * Намира се в библиотеката <algorithm>, която сме включили в програмата.
     * При сортиране на масиви приема като аргументи указатели към първия и последния
     * елемент в масива.
     * 
     * Ако сте забравили, името масива просто представлява указател към първия му
     * елемент.
     * 
     * Ако го съберем с броя на елементите - получаваме изместване до последния такъв.
     * 
     * След изпълнение на долния ред:
     */
    cout << datesArray << " " << datesArray + numberOfDates << endl << endl;
    /* 
     * се вижда, че това са някакви адреси в паметта.
     * 
     * За да сортираме някакви елементи е нужно да можем да ги сравняваме.
     * Точно с тази цел предефинирахме оператора < за сравнение на дати.
     * Остана да сортираме масива:
     */
    sort(datesArray, datesArray + numberOfDates);

    // И да изпечатаме сортираните стойности:
    for (int i = 0; i < numberOfDates; i++) {
        cout << datesArray[i] << endl;
    }

    cout << "==============================================" << endl;


    /*
     * В стандартната библиотека на С++ има нещо много яко, наречено vector.
     * (Няма нищо общо с онзи вектор, който учите по геометрия)
     * 
     * Това е динамичен масив, ака масив, който сам се грижи за броя на елементите си.
     * В началото е празен. След добавяне на първя елемент се разширява до 1 елемент.
     * След добавяне на втория - до 2, после 4, 8 и т.н. х2.
     * 
     * .size() - Колко елемента имате в момента;
     * .capacity() - За колко елемента има място в момента;
     * .begin() - указател към 1вия елемент;
     * .end() - към последния + 1;
     * 
     * http://www.cplusplus.com/reference/vector/vector/
     */

    vector<Date> dates;

    for (int i = 0; i < numberOfDates; i++) {
        dates.push_back(datesArray[i]);
    }

    cout << *dates.begin() << "  " << *(dates.end() - 1) << endl << endl;

    //сортиране на вектор. В случая няма смисъл, защото вкарахме сортирани данни
    sort(dates.begin(), dates.end());

    //Елементите във вектора се достъпват по същия начим като при масива:
    for (int i = 0; i < numberOfDates; i++) {
        cout << dates[i] << endl;
    }

    return 0;
}

